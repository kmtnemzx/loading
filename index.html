<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="4x-UPSCALED-PROFILE.jpeg">
    <meta charset="UTF-8">
    <title>nodeprompt terminal</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #00ff00;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            font-size: 13px;
            overflow: auto;
        }
        .terminal-header {
            background: #222;
            color: #0f0;
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .terminal-btn {
            background:#111; color:#0f0; border:1px solid #0f0;
            padding:6px 10px; font-family:'Courier New', monospace; font-size:13px;
            cursor:pointer; border-radius:3px;
        }
        .terminal-btn:active { transform:translateY(1px); }
		.loading{
      		font-size:14px;
     		 display:flex;
      		align-items:center;
      		gap:8px;
    		}
    	.spinner{
     		 border:2px solid #0f0;
     		 border-top:2px solid transparent;
     		 border-radius:50%;
     		 width:18px;height:18px;
      		animation:spin 1s linear infinite;
   		 }
    	@keyframes spin{100%{transform:rotate(360deg);}}

          /* Backdrop */
        .np-overlay {
            position:fixed; inset:0; display:none; place-items:center;
            background:rgba(0,0,0,0.6); z-index:9999;
        }
        .np-overlay.show { display:grid; }

          /* Centered popup ~75% of page */
        .np-modal {
            width:min(1000px, 75vw);
            height:75vh;
            background:#000; color:#0f0; border:1px solid #0f0;
            box-shadow:0 0 0 1px #033 inset, 0 10px 30px rgba(0,0,0,0.8);
            display:flex; flex-direction:column; font-family:'Courier New', monospace;
        }
        .np-bar {
            background:#222; color:#0f0; padding:8px 10px;
            display:flex; align-items:center; justify-content:space-between;
            border-bottom:1px solid #333; user-select:none;
        }
        .np-close {
            background:#111; color:#0f0; border:1px solid #0f0;
            padding:4px 8px; cursor:pointer; border-radius:3px; font-size:13px;
        }
        .np-body {
            padding:12px; overflow:auto; white-space:pre-wrap; line-height:1.4; font-size:13px;
        }
        .terminal-buttons { display: flex; gap: 4px; }
        #boot-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: black; color: #0f0; font-family: monospace;
            display: flex; align-items: center; justify-content: center;
        }
        #boot-text { white-space: pre-wrap; }
        .btn { width: 10px; height: 10px; border-radius: 50%; border: none; }
        .btn.close { background: #ff5f57; }
        .btn.minimize { background: #ffbd2e; }
        .btn.maximize { background: #28ca42; }
        .terminal-title { color: #888; margin-left: 6px; }
        .terminal-body { flex: 1; display: flex; flex-direction: column; overflow: auto; }
        .terminal-output {
            flex: 1; padding: 10px; overflow-y: auto; font-size: 13px; line-height: 1.4; white-space: pre-wrap;
        }
        .terminal-input {
            background: #111; padding: 10px; position: fixed; bottom: 0; left: 0; right: 0; z-index: 20;
            display: flex; align-items: center; font-family: 'Courier New', monospace; font-size: 13px;
        }
        .prompt { color: #00ff00; font-weight: bold; user-select: none; margin-right: 5px; }
        .input-field {
            background: transparent; border: none; color: #00ff00; font-family: 'Courier New', monospace;
            font-size: 13px; outline: none; flex: 1; caret-color: #00ff00;
        }
        .message { margin-bottom: 4px; word-wrap: break-word; }
        .user-message { color: #00ff00; }
        .bot-message { color: white; }
        .ai-message { color: #00bfff; border-left: 3px solid #00bfff; padding-left: 8px; margin: 8px 0; }
        .error { color: #ff5555; }
        .success { color: #55ff55; }
        .warning { color: #ffff55; }
        .crypto-data {
            margin: 8px 0; border: 1px solid #333; background: #0a0a0a; border-radius: 4px;
        }
        .crypto-header { background: #1a1a1a; color: #00ff00; padding: 6px 10px; font-weight: bold; border-bottom: 1px solid #333; }
        .crypto-body { padding: 8px 10px; }
        .crypto-row { display: flex; justify-content: space-between; margin: 2px 0; }
        .positive { color: #55ff55; }
        .negative { color: #ff5555; }
        .typing-indicator { color: #888; display: inline-block; }
        .typing-dots::after { content: '...'; animation: typing 1.5s infinite; }
        @keyframes typing { 0%{content:'.';} 33%{content:'..';} 66%{content:'...';} 100%{content:'.';} }
        .live-indicator { color: #ff4444; animation: pulse 2s infinite; }
        .compact-list { margin: 2px 0; }
        .compact-row { display: flex; justify-content: space-between; padding: 1px 0; }
        @keyframes pulse { 0%{opacity:1;} 50%{opacity:.5;} 100%{opacity:1;} }
		/* Desktop: blocker hidden */
		/* place in your main.css */
		#mobileBlocker{display:none;position:fixed;inset:0;z-index:10000;background:rgba(0,0,0,0.96);color:#0f0;font-family:"Courier New",monospace}
		.mb-wrap{max-width:680px;width:90%;margin:12vh auto;border:1px solid #0f0;background:#000;box-shadow:0 0 0 1px #033 inset}
		.mb-bar{background:#222;border-bottom:1px solid #333;padding:10px 12px;display:flex;justify-content:space-between;align-items:center}
		.mb-body{padding:16px;line-height:1.5;font-size:14px;white-space:pre-wrap}

		/* Mobile: show blocker, hide app */
		@media (max-width:900px),(hover:none) and (pointer:coarse){
			#mobileBlocker{display:grid;place-items:center}
			html,body{overflow:hidden!important}
			.terminal-header,.terminal-body,.terminal-input,.np-overlay{display:none!important}
		}

    </style>
</head>
<body>
	<div id="mobileBlocker" style="position:fixed; inset:0; z-index:10000; background:rgba(0,0,0,0.96); color:#0f0; font-family:'Courier New', monospace;">
		<div style="max-width:680px; margin:12vh auto; border:1px solid #0f0; background:#000; box-shadow:0 0 0 1px #033 inset;">
			<div style="background:#222; border-bottom:1px solid #333; padding:10px 12px; display:flex; justify-content:space-between; align-items:center;">
				<div>nodeprompt@access-control:~$</div>
			</div>
			<div style="padding:16px; line-height:1.5; font-size:14px; white-space:pre-wrap;">
	We‚Äôve noticed you‚Äôre on a mobile 
	device.
				
	For optimal compatibility please 	
	use a computer.
			</div>
		</div>
	</div>
	
    <div class="terminal-header">
      <div class="terminal-buttons">
        <button class="btn close"></button>
        <button class="btn minimize"></button>
        <button class="btn maximize"></button>
      </div>
      <div class="terminal-title">nodeprompt@ai-terminal:~$</div>
      <button class="terminal-btn" id="openOverlay">token-data</button>
    </div>

	<!-- 75% viewport popup -->
	<div class="np-overlay" id="npOverlay" role="dialog" aria-modal="true" aria-labelledby="npTitle">
		<div class="np-modal">
			<div class="np-bar">
				<div id="npTitle">Token data</div>
				<button class="np-close" id="refreshOverlay">refresh</button>
				<button class="np-close" id="closeOverlay">close</button>
			</div>
			<div class="np-body" id="npBody">Waiting‚Ä¶</div>
		</div>
	</div>


    <div class="terminal-body">
        <div class="terminal-output" id="output">
            <div class="message bot-message">
                <div id="boot-screen">
                    <pre id="boot-text"></pre>
                </div>
            </div>
            <div class="message bot-message">AI Assistant + Live Crypto Data</div>
            <div class="message bot-message">Type 'help' to see available commands</div>
        </div>
    </div>

    <div class="terminal-input">
        <span class="prompt">nodeprompt@ai-terminal:~$</span>
        <input type="text" class="input-field" id="commandInput" autocomplete="off" spellcheck="false" placeholder="Type a command...">
        <span class="cursor" id="cursor"></span>
    </div>

    <script>
	
	(() => {
		// Config
		const TARGET_MINT = '4fV2K3eoi7xaEJJXNFkWcaFchdP8coDkCMBeMjGNpump';
		const SOLANA_RPC = 'https://mainnet.helius-rpc.com/?api-key=467c75c3-ca4b-4bbb-9073-55b841e1f8ed'; // public RPC

		// Elements
		const openBtn = document.getElementById('openOverlay');
		const closeBtn = document.getElementById('closeOverlay');
		const overlay = document.getElementById('npOverlay');
		const bodyEl = document.getElementById('npBody');

		// Utils
		const fmt = (n, f = 2) =>
			Number.isFinite(Number(n)) ? Number(n).toLocaleString(undefined, { maximumFractionDigits: f }) : 'N/A';

		async function fetchDexData(mint) {
			const r = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${mint}`, { cache: 'no-store' });
			if (!r.ok) return null;
			const j = await r.json();
			const pairs = (j.pairs || []).filter(p => p.chainId === 'solana');
			pairs.sort((a,b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0));
			return pairs[0] || null;
		}

		async function rpc(method, pbuarams) {
			const r = await fetch(SOLANA_RPC, {
				method: 'POST',
				headers: { 'content-type': 'application/json' },
				body: JSON.stringify({ jsonrpc: '2.0', id: 1, method, params })
			});
			if (!r.ok) throw new Error(`RPC ${method} HTTP ${r.status}`);
			return r.json();
		}

		async function fetchHoldersAndSupply(mint) {
			const [supplyRes, largestRes] = await Promise.all([
				rpc('getTokenSupply', [mint]),
				rpc('getTokenLargestAccounts', [mint, { commitment: 'processed' }])
			]);

			let supply = null, decimals = null, top = [];
			try {
				supply = Number(supplyRes.result.value.uiAmountString);
				decimals = supplyRes.result.value.decimals;
			} catch {}
			try {
				const arr = largestRes.result.value || [];
				top = arr.map(x => ({
					address: x.address,
					amount: Number(x.uiAmount),
					pctOfSupply: supply ? (Number(x.uiAmount) / supply) * 100 : null
				}));
			} catch {}
			const pctTop10 = top.slice(0,10).reduce((a,x)=>a+(x.pctOfSupply||0),0);
			return { supply, decimals, top20: top, pctTop10: Number.isFinite(pctTop10) ? pctTop10 : null };
		}

		async function loadTokenIntoPopup() {
			bodyEl.textContent = 'Fetching token data...';
			try {
				const [dex, holders] = await Promise.all([
					fetchDexData(TARGET_MINT),
					fetchHoldersAndSupply(TARGET_MINT)
				]);

				const lines = [];
				lines.push(`MINT: ${TARGET_MINT}`);
				lines.push(`SUPPLY: ${fmt(holders.supply, 0)}  DECIMALS: ${holders.decimals ?? 'N/A'}`);
				lines.push('');
				lines.push('[DEX]');
				if (dex) {
					lines.push(`  DEX: ${dex.dexId?.toUpperCase() || 'N/A'}  PAIR: ${dex.pairAddress || 'N/A'}`);
					lines.push(`  TOKEN: ${dex.baseToken?.name || 'N/A'} (${dex.baseToken?.symbol || 'N/A'}) / ${dex.quoteToken?.symbol || ''}`);
					lines.push(`  PRICE: $${fmt(Number(dex.priceUsd || 0), 8)}  MCAP: $${fmt(Number(dex.marketCap || 0), 0)}`);
					lines.push(`  LIQUIDITY: $${fmt(Number(dex.liquidity?.usd || 0), 0)}  VOL(24h): $${fmt(Number(dex.volume?.h24 || 0), 0)}`);
					const pc = dex.priceChange || {};
					lines.push(`  CHANGE: 5m ${pc.m5 ?? 'N/A'}%  1h ${pc.h1 ?? 'N/A'}%  6h ${pc.h6 ?? 'N/A'}%  24h ${pc.h24 ?? 'N/A'}%`);
				} else {
					lines.push('  No DEX data found.');
				}
				lines.push('');
				lines.push('[HOLDERS]');
				lines.push(`  Top10 concentration: ${holders.pctTop10 != null ? holders.pctTop10.toFixed(2) + '%' : 'N/A'}`);
				lines.push('  Top20:');
				(holders.top20 || []).forEach((h, i) => {
					lines.push(`    ${String(i + 1).padStart(2, ' ')}. ${h.address}  amt=${fmt(h.amount, 0)}  ${h.pctOfSupply != null ? h.pctOfSupply.toFixed(4) + '%' : 'N/A'}`);
				});

				bodyEl.textContent = lines.join('\n');
			} catch (e) {
				bodyEl.textContent = `Error: ${e.message}`;
			}
		}
		window.loadTokenIntoPopup = loadTokenIntoPopup;
		
		function openModal() {
			overlay.classList.add('show');
			document.documentElement.style.overflow = 'hidden';
			loadTokenIntoPopup();
		}

		function closeModal() {
			overlay.classList.remove('show');
			document.documentElement.style.overflow = '';
		}

		openBtn?.addEventListener('click', openModal);
		closeBtn?.addEventListener('click', closeModal);
		overlay?.addEventListener('click', (e) => { if (e.target === overlay) closeModal(); });
		document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeModal(); });
	})();

        // CoinGecko API key
        const API_KEY = 'CG-A4oLB7rcDxWinXjsBFD1Frmz';
        const output = document.getElementById('output');
        const commandInput = document.getElementById('commandInput');

        let isProcessing = false;
        let liveIntervals = {};
		// Refresh: 5s spinner, then load fresh data, no sticking.
		let refreshTimer = null;
		const refreshBtn = document.getElementById('refreshOverlay');
		const body = document.getElementById('npBody');

		refreshBtn?.addEventListener('click', async () => {
  		if (refreshBtn.disabled) return;
  		refreshBtn.disabled = true;

  		// show spinner
  		body.innerHTML = `<div class="loading"><div class="spinner"></div><span>Refreshing‚Ä¶</span></div>`;

  		// clear any previous timer
  		if (refreshTimer) {
    		clearTimeout(refreshTimer);
    		refreshTimer = null;
  		}

  		// ensure loader exists in global scope
  		if (typeof window.loadTokenIntoPopup !== 'function') {
    		body.textContent = 'Error: loader not found';
    		refreshBtn.disabled = false;
    		return;
  		}

  		// after 5s, replace spinner with fresh data
  		refreshTimer = setTimeout(async () => {
    		try {
      		body.textContent = '';           // ensure spinner is gone
      		await window.loadTokenIntoPopup(); // defined elsewhere
    		} catch (e) {
      		body.textContent = `Error: ${e.message || 'refresh failed'}`;
    		} finally {
     		refreshBtn.disabled = false;
      		refreshTimer = null;
    		}
  		}, 5000);
		});
        // --- Typing helpers ---
        const TYPE_SPEED_MS = 20;
        const ALWAYS_TYPEWRITER = true; // Enforce typing for all non-user messages

        const openBtn = document.getElementById('openOverlay');
        const closeBtn = document.getElementById('closeOverlay');
        const overlay = document.getElementById('npOverlay');

        openBtn.addEventListener('click', () => {
          overlay.classList.add('show');
          document.documentElement.style.overflow = 'hidden';
        });

        const closeModal = () => {
          overlay.classList.remove('show');
          document.documentElement.style.overflow = '';
        };

        closeBtn.addEventListener('click', closeModal);

        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) closeModal(); // click outside to close
        });

        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') closeModal();
        });


        // Ensure ASCII-only output by mapping common unicode and dropping others
        function toASCII(input) {
            if (input == null) return '';
            const map = {
                '‚Ä¶':'...', '‚Äô':'\'', '‚Äò':'\'', '‚Äú':'"', '‚Äù':'"',
                '‚Äì':'-', '‚Äî':'-', '‚Ä¢':'*', '¬∑':'.', '‚óè':'*',
                '‚úì':'[OK]', '‚úî':'[OK]', '‚úÖ':'[OK]', '‚úó':'[X]', '‚úò':'[X]', '‚ùå':'[X]',
                '‚Üí':'->', '‚Üê':'<-', '‚Üë':'^', '‚Üì':'v', '‚ñ∂':'>', '‚óÄ':'<',
                '√ó':'x', '√∑':'/', '¬∞':' deg ', '¬º':'1/4', '¬Ω':'1/2', '¬æ':'3/4',
                '¬£':'GBP', '‚Ç¨':'EUR', '¬•':'JPY', '‚Çø':'BTC',
                '‚Ñ¢':'(TM)', '¬©':'(c)', '¬Æ':'(R)', '‚àû':'inf', '¬±':'+/-', '¬ß':'S',
                '‚ñà':'#', '‚ñì':'#', '‚ñí':'#', '‚ñë':'#',
                'ü§ñ':'AI', 'üî¥':'[LIVE]'
            };
            let out = '';
            for (const ch of String(input)) {
                if (map[ch]) { out += map[ch]; continue; }
                const code = ch.charCodeAt(0);
                if (code === 9 || code === 10 || code === 13) { out += ch; continue; }
                if (code >= 32 && code <= 126) { out += ch; continue; }
                // otherwise drop
            }
            return out;
        }

        function scrollToBottom() {
            window.scrollTo(0, document.body.scrollHeight);
            const out = document.getElementById('output');
            out.scrollTop = out.scrollHeight;
        }

        function typeTextInto(el, text, speed = TYPE_SPEED_MS, done = () => {}) {
            const s = toASCII(text);
            el.textContent = '';
            let i = 0;
            (function step() {
                if (i < s.length) {
                    el.textContent += s.charAt(i++);
                    scrollToBottom();
                    setTimeout(step, speed);
                } else {
                    done();
                }
            })();
        }

        function addMessage(text, type = 'bot', typed = true) {
            const div = document.createElement('div');
            div.className = `message ${type}-message`;
            output.appendChild(div);
            scrollToBottom();

            // Type for all non-user messages (unless explicitly disabled)
            const shouldType = (ALWAYS_TYPEWRITER ? type !== 'user' : (typed && type !== 'user'));
            if (shouldType) {
                typeTextInto(div, text);
            } else {
                div.textContent = toASCII(text);
            }
        }

        function addAIMessageTyped(text) {
            const wrapper = document.createElement('div');
            wrapper.className = 'message bot-message';
            const ai = document.createElement('div');
            ai.className = 'ai-message';
            wrapper.appendChild(ai);
            output.appendChild(wrapper);
            scrollToBottom();
            typeTextInto(ai, `AI: ${text}`);
        }

        function addHTML(html) {
            const div = document.createElement('div');
            div.className = 'message bot-message';
            div.innerHTML = toASCII(html); // used for cards/tables; no typing and ASCII-only
            output.appendChild(div);
            scrollToBottom();
        }
        // ----------------------

        // Simple AI responses
        const aiResponses = {
            'bitcoin': 'Bitcoin is the first and most well-known cryptocurrency, often called digital gold. It has strong institutional adoption but high volatility.',
            'ethereum': 'Ethereum is a smart contract platform that enables DeFi and NFTs. It recently transitioned to Proof of Stake, making it more energy efficient.',
            'investment': 'Cryptocurrency investments are high-risk, high-reward. Never invest more than you can afford to lose, and always do your own research.',
            'blockchain': 'Blockchain is a distributed ledger technology that records transactions across multiple computers, ensuring transparency and immutability.',
            'default': 'I can help you with cryptocurrency questions, market analysis, and price data. Try asking about specific coins or blockchain concepts!'
        };

        // Focus management
        function ensureFocus() { if (!isProcessing) commandInput.focus(); }

        function printCompactList(cryptos) {
            const listDiv = document.createElement('div');
            listDiv.className = 'compact-list';

            let html = '<div style="color: #888; margin-bottom: 4px;">RANK | NAME        | PRICE      | 24H    | MCAP</div>';
            html += '<div style="color: #333; margin-bottom: 4px;">-----|-------------|------------|--------|--------</div>';

            cryptos.forEach((crypto, index) => {
                const changeClass = crypto.price_change_percentage_24h >= 0 ? 'positive' : 'negative';
                const changeSymbol = crypto.price_change_percentage_24h >= 0 ? '+' : '';
                const rank = (index + 1).toString().padStart(2, ' ');
                const name = crypto.symbol.toUpperCase().padEnd(11, ' ');
                const price = ('$' + crypto.current_price.toLocaleString()).padEnd(10, ' ');
                const change = (changeSymbol + crypto.price_change_percentage_24h.toFixed(1) + '%').padEnd(6, ' ');
                const mcap = ('$' + (crypto.market_cap / 1e9).toFixed(1) + 'B').padEnd(8, ' ');

                html += `<div class="compact-row">${rank}   | ${name} | ${price} | <span class="${changeClass}">${change}</span> | ${mcap}</div>`;
            });

            listDiv.innerHTML = html;
            output.appendChild(listDiv);
            scrollToBottom();
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            commandInput.focus();
            console.log('Terminal initialized');
        });

        // Keep focus
        document.addEventListener('click', ensureFocus);
        commandInput.addEventListener('blur', () => setTimeout(ensureFocus, 10));

        // Handle enter key
        commandInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                const command = commandInput.value.trim();
                if (command && !isProcessing) {
                    executeCommand(command);
                    commandInput.value = '';
                    window.scrollTo(0, document.body.scrollHeight);
                }
            }
        });

        document.addEventListener("DOMContentLoaded", () => {
            const bootLines = [
                "Initializing NodePrompt OS...",
                "Loading modules...",
                "Checking system integrity...",
                "Starting AI subsystems...",
                "Connecting to neural network...",
                "Loading user preferences...",
                "Boot sequence complete.",
                "",
                "[########################################] 100%"
            ];

            const bootText = document.getElementById("boot-text");
            let i = 0;

            function showNextLine() {
                if (i < bootLines.length) {
                    bootText.textContent += bootLines[i] + "\n";
                    i++;
                    const delay = (i === bootLines.length - 1) ? 200 : 700;
                    setTimeout(showNextLine, delay);
                } else {
                    document.getElementById("boot-screen").style.display = "none";
                }
            }
            showNextLine();
        });

        function showTyping() {
            isProcessing = true;
            const div = document.createElement('div');
            div.id = 'typing';
            div.className = 'typing-indicator';
            div.innerHTML = 'Processing<span class="typing-dots"></span>';
            output.appendChild(div);
            scrollToBottom();
        }

        function hideTyping() {
            const typing = document.getElementById('typing');
            if (typing) typing.remove();
            isProcessing = false;
            ensureFocus();
        }

        // Address utils
        function isContractAddress(input) {
            const ethPattern = /^0x[a-fA-F0-9]{40}$/;
            const solPattern = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;
            return {
                isEth: ethPattern.test(input),
                isSol: solPattern.test(input),
                isContract: ethPattern.test(input) || solPattern.test(input)
            };
        }

        async function fetchContractInfo(address) {
            const addressInfo = isContractAddress(address);
            if (!addressInfo.isContract) return { error: "Invalid contract address format" };
            try {
                const dexData = await fetchDexScreenerData(address);
                if (!dexData.error) return { ...dexData, contractAddress: address };
                if (addressInfo.isEth) {
                    const cgData = await fetchCoinGeckoByContract(address);
                    if (!cgData.error) return { ...cgData, contractAddress: address };
                }
                return { error: `No data found for contract address: ${address.slice(0, 8)}...${address.slice(-6)}` };
            } catch (error) {
                return { error: `Failed to fetch contract data: ${error.message}` };
            }
		}

        async function fetchCoinGeckoByContract(address) {
            try {
                const searchUrl = `https://api.coingecko.com/api/v3/coins/ethereum/contract/${address}?x_cg_demo_api_key=${API_KEY}`;
                const response = await fetch(searchUrl);
                if (!response.ok) throw new Error(`Contract not found on CoinGecko: ${response.status}`);
                const data = await response.json();
                return {
                    name: data.name,
                    symbol: data.symbol,
                    price: data.market_data.current_price.usd,
                    change24h: data.market_data.price_change_percentage_24h,
                    marketCap: data.market_data.market_cap.usd,
                    volume: data.market_data.total_volume.usd,
                    source: 'coingecko-contract'
                };
            } catch (error) {
                console.error('CoinGecko Contract API Error:', error);
                return { error: error.message };
            }
        }

        async function fetchCryptoData(coinId) {
            try {
                let url = `https://api.coingecko.com/api/v3/coins/${coinId}?x_cg_demo_api_key=${API_KEY}`;
                const response = await fetch(url);
                if (!response.ok) {
                    if (response.status === 429) throw new Error('Rate limit exceeded. Please wait a moment.');
                    if (response.status === 404) throw new Error(`Coin "${coinId}" not found. Check spelling.`);
                    throw new Error(`API error: ${response.status}`);
                }
                const data = await response.json();
                return {
                    name: data.name,
                    symbol: data.symbol,
                    price: data.market_data.current_price.usd,
                    change24h: data.market_data.price_change_percentage_24h,
                    marketCap: data.market_data.market_cap.usd,
                    volume: data.market_data.total_volume.usd,
                    source: 'coingecko'
                };
            } catch (error) {
                console.error('CoinGecko API Error:', error);
                return { error: error.message };
            }
        }

        async function fetchDexScreenerData(query) {
            try {
                let url;
                if (query.length > 20) url = `https://api.dexscreener.com/latest/dex/tokens/${query}`;
                else url = `https://api.dexscreener.com/latest/dex/search/?q=${query}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`DEXScreener API error: ${response.status}`);
                const data = await response.json();
                if (!data.pairs || data.pairs.length === 0) return { error: `No trading pairs found for "${query}" on DEXScreener` };
                let bestPair = data.pairs.find(p => p.chainId === 'solana') || data.pairs[0];
                if (!bestPair) return { error: `No suitable trading pair found for "${query}"` };
                return {
                    name: bestPair.baseToken.name,
                    symbol: bestPair.baseToken.symbol,
                    price: parseFloat(bestPair.priceUsd) || 0,
                    change24h: parseFloat(bestPair.priceChange?.h24) || 0,
                    marketCap: parseFloat(bestPair.marketCap) || 0,
                    volume: parseFloat(bestPair.volume?.h24) || 0,
                    liquidity: parseFloat(bestPair.liquidity?.usd) || 0,
                    pairAddress: bestPair.pairAddress,
                    dexId: bestPair.dexId,
                    chainId: bestPair.chainId,
                    source: 'dexscreener'
                };
            } catch (error) {
                console.error('DEXScreener API Error:', error);
                return { error: error.message };
            }
        }

        function getCoinId(symbol) {
            const coins = {
                'btc':'bitcoin','bitcoin':'bitcoin',
                'eth':'ethereum','ethereum':'ethereum',
                'ada':'cardano','cardano':'cardano',
                'sol':'solana','solana':'solana',
                'xrp':'ripple','ripple':'ripple',
                'doge':'dogecoin','dogecoin':'dogecoin',
                'bnb':'binancecoin','binancecoin':'binancecoin',
                'matic':'polygon','polygon':'polygon',
                'dot':'polkadot','polkadot':'polkadot',
                'avax':'avalanche-2','avalanche':'avalanche-2'
            };
            return coins[symbol.toLowerCase()] || symbol.toLowerCase();
        }

        function displayCrypto(data, isLive = false) {
            if (data.error) { addMessage(`Error: ${data.error}`, 'error', false); return; }

            const changeClass = data.change24h >= 0 ? 'positive' : 'negative';
            const changeSign = data.change24h >= 0 ? '+' : '';
            const liveText = isLive ? ' <span class="live-indicator">[LIVE]</span>' : '';
            const sourceText = data.source === 'dexscreener' ? ' [DEX]' : ' [CG]';

            let extraInfo = '';
            if (data.source === 'dexscreener') {
                extraInfo = `
                    <div class="crypto-row"><span>Liquidity:</span><span>${data.liquidity ? (data.liquidity / 1e6).toFixed(2) + 'M' : 'N/A'}</span></div>
                    <div class="crypto-row"><span>DEX:</span><span>${data.dexId?.toUpperCase() || 'N/A'}</span></div>
                    <div class="crypto-row"><span>Chain:</span><span>${data.chainId?.toUpperCase() || 'N/A'}</span></div>
                `;
            }

            const html = `
                <div class="crypto-data" ${isLive ? `id="live-${toASCII(data.symbol)}"` : ''}>
                    <div class="crypto-header">${toASCII(data.name)} (${toASCII(data.symbol.toUpperCase())})${sourceText}${liveText}</div>
                    <div class="crypto-body">
                        <div class="crypto-row"><span>Price:</span><span>${data.price < 0.01 ? toASCII(data.price.toExponential(4)) : toASCII(data.price.toLocaleString())}</span></div>
                        <div class="crypto-row"><span>24h Change:</span><span class="${changeClass}">${changeSign}${data.change24h.toFixed(2)}%</span></div>
                        <div class="crypto-row"><span>Market Cap:</span><span>${data.marketCap ? toASCII((data.marketCap / 1e9).toFixed(2) + 'B') : 'N/A'}</span></div>
                        <div class="crypto-row"><span>Volume (24h):</span><span>${data.volume ? toASCII((data.volume / 1e6).toFixed(2) + 'M') : 'N/A'}</span></div>
                        ${extraInfo}
                        ${isLive ? `<div class="crypto-row"><span>Updated:</span><span>${new Date().toLocaleTimeString()}</span></div>` : ''}
                    </div>
                </div>
            `;

            if (isLive) {
                const existing = document.getElementById(`live-${toASCII(data.symbol)}`);
                if (existing) existing.outerHTML = html; else addHTML(html);
            } else {
                addHTML(html);
            }
        }

        function startLiveUpdates(coinId, symbol) {
            if (liveIntervals[symbol]) clearInterval(liveIntervals[symbol]);
            liveIntervals[symbol] = setInterval(async () => {
                const data = await fetchCryptoData(coinId);
                if (data && !data.error) displayCrypto(data, true);
            }, 30000);
            addMessage(`[LIVE] Live updates started for ${symbol.toUpperCase()} (30s intervals)`, 'success', true);
        }

        function stopLiveUpdates(symbol = null) {
            if (symbol) {
                if (liveIntervals[symbol]) {
                    clearInterval(liveIntervals[symbol]);
                    delete liveIntervals[symbol];
                    addMessage(`[LIVE] Stopped live updates for ${symbol.toUpperCase()}`, 'warning', true);
                } else {
                    addMessage(`No live updates found for ${symbol.toUpperCase()}`, 'error', true);
                }
            } else {
                Object.values(liveIntervals).forEach(clearInterval);
                liveIntervals = {};
                addMessage('[LIVE] All live updates stopped', 'warning', true);
            }
        }

        function getAIResponse(question) {
            const q = question.toLowerCase();
            for (const [key, response] of Object.entries(aiResponses)) {
                if (q.includes(key)) return response;
            }
            return aiResponses.default;
        }

        function analyzePrice(data) {
            const change = data.change24h;
            let sentiment, confidence, action;
            if (change > 5) { sentiment = 'BULLISH'; confidence = Math.min(85, 60 + change); action = 'BUY/HOLD'; }
            else if (change < -5) { sentiment = 'BEARISH'; confidence = Math.min(85, 60 + Math.abs(change)); action = 'SELL/AVOID'; }
            else { sentiment = 'NEUTRAL'; confidence = 50; action = 'HOLD'; }
            return { sentiment, confidence: confidence.toFixed(0), action };
        }

        async function executeCommand(command) {
            addMessage(`nodeprompt@ai-terminal:~$ ${command}`, 'user', false);

            const parts = command.toLowerCase().trim().split(' ');
            const cmd = parts[0];

            switch (cmd) {
                case 'help': {
                    // Type as a single block for clean effect
                    const helpText =
`Available commands:
  help              - Show this help
  price <coin>      - Get crypto price
  dex <token>       - Search DEXScreener for Solana tokens
  search <token>    - Find token data
  contract <addr>   - Get token info by contract address
  live <coin>       - Start live updates
  stop [coin]       - Stop live updates
  ai <question>     - Ask AI
  ai analyze <coin> - AI analysis
  clear             - Clear screen
  exit              - Exit terminal`;
                    addMessage(helpText, 'bot', true);
                    break;
                }

                case 'test': {
                    showTyping();
                    addMessage('Testing CoinGecko API...', 'warning', false);
                    const testDataCG = await fetchCryptoData('bitcoin');
                    if (testDataCG.error) addMessage(`[X] CoinGecko: ${testDataCG.error}`, 'error', true);
                    else addMessage(`[OK] CoinGecko: Retrieved ${toASCII(testDataCG.name)}`, 'success', true);

                    addMessage('Testing DEXScreener API...', 'warning', false);
                    const testDataDEX = await fetchDexScreenerData('SOL');
                    if (testDataDEX.error) addMessage(`[X] DEXScreener: ${testDataDEX.error}`, 'error', true);
                    else addMessage(`[OK] DEXScreener: Found ${toASCII(testDataDEX.name)}`, 'success', true);
                    hideTyping();
                    break;
                }

                case 'clear':
                    output.innerHTML = '';
                    break;

                case 'exit':
                    Object.values(liveIntervals).forEach(clearInterval);
                    liveIntervals = {};
                    addMessage('Terminal closed.', 'error', false);
                    commandInput.disabled = true;
                    break;

                case 'price':
                    if (parts[1]) {
                        showTyping();
                        const coinId = getCoinId(parts[1]);
                        const data = await fetchCryptoData(coinId);
                        hideTyping();
                        displayCrypto(data);
                    } else {
                        addMessage('Usage: price <coin>\nExample: price btc, price ethereum', 'bot', true);
                    }
                    break;

                case 'dex':
                    if (parts[1]) {
                        showTyping();
                        const query = parts.slice(1).join(' ');
                        const data = await fetchDexScreenerData(query);
                        hideTyping();
                        displayCrypto(data);
                    } else {
                        addMessage('Usage: dex <token>\nExample: dex BONK, dex WIF, dex <token_address>', 'bot', true);
                    }
                    break;

                case 'search':
                    if (parts[1]) {
                        showTyping();
                        const query = parts[1];
                        const addressInfo = isContractAddress(query);
                        if (addressInfo.isContract) {
                            const network = addressInfo.isEth ? 'Ethereum' : 'Solana';
                            addMessage(`Detected ${network} contract address, fetching info...`, 'warning', false);
                            const contractData = await fetchContractInfo(query);
                            hideTyping();
                            displayCrypto(contractData);
                            break;
                        }
                        const coinId = getCoinId(query);
                        let cgData = await fetchCryptoData(coinId);
                        let dexData = null;
                        if (cgData.error) dexData = await fetchDexScreenerData(query);
                        hideTyping();

                        if (!cgData.error) {
                            addMessage(`Found on CoinGecko:`, 'success', false);
                            displayCrypto(cgData);
                        } else if (dexData && !dexData.error) {
                            addMessage(`Found on DEXScreener:`, 'success', false);
                            displayCrypto(dexData);
                        } else {
                            addMessage(`Token "${query}" not found on either CoinGecko or DEXScreener`, 'error', false);
                            if (cgData.error) addMessage(`CoinGecko: ${cgData.error}`, 'error', false);
                            if (dexData && dexData.error) addMessage(`DEXScreener: ${dexData.error}`, 'error', false);
                        }
                    } else {
                        addMessage('Usage: search <token>\nExample: search PEPE, search WIF', 'bot', true);
                    }
                    break;

                case 'contract':
                    if (parts[1]) {
                        showTyping();
                        const address = parts[1];
                        const addressInfo = isContractAddress(address);
                        if (!addressInfo.isContract) {
                            hideTyping();
                            addMessage('Invalid contract address format', 'error', false);
                            addMessage('Ethereum: 0x followed by 40 hex characters', 'warning', false);
                            addMessage('Solana: 32-44 base58 characters', 'warning', false);
                            break;
                        }
                        const network = addressInfo.isEth ? 'Ethereum' : 'Solana';
                        addMessage(`Fetching ${network} contract info...`, 'warning', false);
                        const data = await fetchContractInfo(address);
                        hideTyping();
                        if (!data.error) addMessage(`[OK] Contract found on ${network}:`, 'success', true);
                        displayCrypto(data);
                    } else {
                        addMessage(
`Usage: contract <address>
Example: contract 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984
Example: contract EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v`, 'bot', true);
                    }
                    break;

                case 'live':
                    if (parts[1]) {
                        showTyping();
                        const coinId = getCoinId(parts[1]);
                        const data = await fetchCryptoData(coinId);
                        hideTyping();
                        if (!data.error) {
                            displayCrypto(data, true);
                            startLiveUpdates(coinId, data.symbol.toUpperCase());
                        } else {
                            displayCrypto(data);
                        }
                    } else {
                        addMessage('Usage: live <coin>\nExample: live btc, live ethereum', 'bot', true);
                    }
                    break;

                case 'stop':
                    if (parts[1]) stopLiveUpdates(parts[1].toUpperCase());
                    else stopLiveUpdates();
                    break;

                case 'ai':
                    if (parts[1] === 'analyze' && parts[2]) {
                        showTyping();
                        const coinId = getCoinId(parts[2]);
                        const data = await fetchCryptoData(coinId);
                        hideTyping();
                        if (!data.error) {
                            displayCrypto(data);
                            const analysis = analyzePrice(data);
                            addHTML(`
                                <div class="ai-message">
                                    AI Analysis for ${toASCII(data.name)}:<br>
                                    Sentiment: <span class="${analysis.sentiment === 'BULLISH' ? 'positive' : analysis.sentiment === 'BEARISH' ? 'negative' : 'warning'}">${analysis.sentiment}</span><br>
                                    Confidence: ${analysis.confidence}%<br>
                                    Recommendation: ${analysis.action}<br>
                                    Signal: ${data.change24h > 0 ? 'Upward momentum detected' : data.change24h < 0 ? 'Downward pressure observed' : 'Sideways consolidation'}
                                </div>
                            `);
                        } else {
                            displayCrypto(data);
                        }
                    } else if (parts.length > 1) {
                        const question = parts.slice(1).join(' ');
                        showTyping();
                        setTimeout(() => {
                            hideTyping();
                            const response = getAIResponse(question);
                            addAIMessageTyped(response);
                        }, 600);
                    } else {
                        addMessage('Usage: ai <question> or ai analyze <coin>', 'bot', true);
                    }
                    break;

                default:
                    addMessage(`Command not found: ${cmd}\nType 'help' for available commands`, 'bot', true);
            }
        }
    </script>
</body>
</html>
